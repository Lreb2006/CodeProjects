### 算法学习笔记第一版

#### 占位符

| 占位符 | 对应数据类型           | 描述                               |
|--------|------------------------|------------------------------------|
| `%d`   | `int`                  | 有符号十进制整数                   |
| `%i`   | `int`                  | 与`%d`相同                         |
| `%u`   | `unsigned int`         | 无符号十进制整数                   |
| `%f`   | `float`, `double`      | 浮点数                             |
| `%e`   | `float`, `double`      | 科学记数法表示的浮点数             |
| `%g`   | `float`, `double`      | 根据数值自动选择`%f`或`%e`中的较短者 |
| `%c`   | `char`                 | 字符                               |
| `%s`   | `char *`               | 字符串                             |
| `%p`   | 指针类型               | 指针地址                           |
| `%x`   | `unsigned int`         | 无符号十六进制整数     |
| `%o`   | `unsigned int`         | 八进制整数                         |
| `%lu`  | `unsigned long int`    | 无符号长整型                       |
| `%ld`  | `long int`             | 长整型                             |
| `%%`   | 无                     | 打印百分号本身                     |

#### 变量类型

| 数据类型          | 字节长度（64位系统） | 取值范围                               | 类型描述                             |
|-------------------|----------------------|----------------------------------------|--------------------------------------|
| `char`            | 1                    | -128 到 127 或 0 到 255 (无符号)       | 字符数据类型                         |
| `unsigned char`   | 1                    | 0 到 255                               | 无符号字符数据类型                   |
| `short`           | 2                    | -32,768 到 32,767                      | 短整型                               |
| `unsigned short`  | 2                    | 0 到 65,535                            | 无符号短整型                         |
| `int`             | 4                    | -2,147,483,648 到 2,147,483,647        | 整型                                 |
| `unsigned int`    | 4                    | 0 到 4,294,967,295                     | 无符号整型                           |
| `long`            | 8                    | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 长整型                             |
| `unsigned long`   | 8                    | 0 到 18,446,744,073,709,551,615        | 无符号长整型                         |
| `long long`       | 8                    | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 超长整型（也称为64位整数）         |
| `unsigned long long` | 8               | 0 到 18,446,744,073,709,551,615        | 无符号超长整型                       |
| `float`           | 4                    | 大约±1.175494e-38 至 ±3.402823e+38     | 单精度浮点数                         |
| `double`          | 8                    | 大约±2.225074e-308 至 ±1.797693e+308   | 双精度浮点数                         |

#### 格式化输出

| 格式说明符 | 示例       | 描述                                                                                   |
|------------|------------|----------------------------------------------------------------------------------------|
| 宽度       | `%5d`      | 指定最小字符数，如果数值短于这个宽度，则会根据对齐方式填充空格。                       |
| 精度       | `%.2f`     | 对于浮点数，指定了小数点后的位数；对于字符串，限制了显示的最大字符数。                 |
| 左对齐标志 | `%-5d`     | 使用`-`标志实现左对齐，默认是右对齐。                                                 |
| 正号标志   | `%+d`      | 使用`+`强制输出符号（正或负），即使是正数也会显示加号。                                 |
| 空格标志   | `% d`      | 若无符号，则在正数前加一个空格。                                                       |
| 前缀标志   | `%#x`      | 对于`o`、`x`或`X`，会在非零值前加上相应的前缀（`0`、`0x`或`0X`）。对于`f`类型，保证总是包含小数点。 |
| 零填充     | `%05d`     | 当指定宽度时，用零而非空格填充（仅适用于数值类型）。                                     |
| 长度修饰符 | `%ld`      | 如`l`（长）、`ll`（长长）、`h`（短）、`hh`（字符）等，用于修改数据类型的大小。         |

#### 头文件

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<unordered_map>
#include<unordered_set>
```

#### string字符串

```cpp
string a = "hello";
string a2 = "world";
string a3 = a +" " + a2;    //字符串拼接
```

```cpp
string s;
getline(cin,s);   //获取一整行，包括空格
cout<<s.length()<<endl; //包括空格，不包括\0
```

#### vector动态数组

##### 构造

```cpp
vector<int> v;         // 构造int数组
vector<int> v(100);    // 构造初始长100的int数组
vector<int> v(100, 1); // 构造初始长100的int数组，初值为1，默认初始值为0

vector<vector<int>> mat(100, vector<int> ());       // 构造初始100行，不指定列数的二维数组
vector<vector<int>> mat(100, vector<int> (666, -1)) // 构造初始100行，初始666列的二维数组，初值为-1

vector<int> arr = {1,2,3,4,5};

v.resize(10); //设置数组大小,如果新的大小大于当前大小，则新元素会被默认初始化为0
```

##### 插入

```cpp
v.push_back(2); //在向量的末尾添加一个新的元素
```

##### 遍历

```cpp
for(auto p = v.begin();p!=v.end();p++){  //迭代器，自动调整遍历的空间，p可以看做指针 
 cout<<*p<<" ";
}
//v.end()不是数组的最后一个空间，而是最后一个空间的下一个空间 
```

##### 删除

```cpp
v.pop_back(2);
```

##### 清空

```cpp
v.clear();
```

##### 判空

```cpp
v.empty();  //如果是空返回 `true` 反之返回 `false`
```

##### 获取长度

```cpp
v.size();
```
>vector 获取长度的方法 `.size()` 返回值类型为 `size_t`，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.

```cpp
vector<int> a(65536);
long long a = a.size() * a.size(); // 直接溢出变成0了
```

#### set集合

##### 创建

```cpp
set <int> s; //跟数组的创建相似,但集合中s后面不能有（参数）
```

##### 插入

```cpp
s.insert(2);
```

##### 遍历

```cpp
for(auto p = s.begin();p!=s.end();p++){  //会自动从大到小排序 
    cout<<*p<<" ";
}
```

##### 删除

```cpp
s.erase(2);
```

##### 查找

```cpp
cout<<(s.find(2)!=s.end())<<endl; //查找2是不是集合里的元素，<<()<<括号里整一个是bool值，如果不等于就是1，表明查找成功
//s.find()返回值是一个指针
```

#### map键值对

##### 创建

```cpp
//map是键值对，它会自动将所有的键值对按照建从小到大排序，按照ascII码来排序，h的阿斯克码在w之前,第一个字符相同，就比较第二个
    map<string,int> m;
    m["hello"] = 4;
```

##### 输出

```cpp
//如果存在hello，就返回4，否则返回0
cout<<"hello:"<<m["hello"]<<endl;
```

##### 遍历

```cpp
for(auto p = m.begin();p != m.end();p++){
    cout<<p->first<<":"<<p->second<<endl;   //箭头指向指针，获取所有map的键值对
}
```

##### 获取长度

```cpp
m.size();
```

#### stack栈

##### 创建

```cpp
//栈：先进后出
stack <int> s;
```

##### 插入

```cpp
s.push(1);  //压栈
s.push(2);
s.push(4);
```

##### 删除

```cpp
    s.pop();    //出栈，出最后压的栈
```

##### 获取栈顶

```cpp
cout<<s.top()<<endl;
//无法使用迭代器，只能获取栈顶元素也只能操作栈顶元素，不能从栈底开始遍历
```

##### 获取长度

```cpp
s.size();
```

#### queue队列

##### 创建

```cpp
 //队列：先进先出
    queue <int> q;
```

##### 插入

```cpp
q.push(1);  //入队，入队尾
```

##### 获取队首和队尾

```cpp
cout<<q.front()<<" "<<q.back()<<endl;  //获取队首和获取队尾
```

##### 删除

```cpp
q.pop();    //出队，出队首
```

##### 获取长度

```cpp
q.size();
```

#### map&set(不排序)

```cpp
//unordered_map和unordered_set这两个其实就是不会排序的map和set，它们省去了排序的过程，如果刷题的时候超时了，可以使用这两个
unordered_map <string,int> m;
unordered_set <int> s;
```

#### bitset位运算

##### 插入

```cpp
//bitset类似一个字符数组，但是它是从二进制的低位到高位依次为b[0],b[1]...，所以按照b[i]的方式输出和直接输出b的结果相反
bitset <5> a;       //5表示5个二进制位，初始化为0
bitset <5> b(19);   //19的二进制是10011，所以b[0]=1,b[1]=1,b[2]=0,b[3]=0,b[4]=1
bitset <6> c("111");//111为字符串，字符串只能是0或1，输出结果是000111，不做进制转换
```

##### 遍历

```cpp
for(int i = 0;i<5;i++){
    cout<<b[i]<<" ";
}
```

##### 各种方法

```cpp
cout<<"是否存在1:"<<b.any()<<endl;      //判断是否存在1，有返回1，没有返回0
cout<<"是否不存在1:"<<b.none()<<endl;   //判断是否不存在1，不存在返回1，存在返回0
cout<<"1的个数为:"<<b.count()<<endl;
cout<<"元素个数为:"<<b.size()<<endl;
cout<<"下标为i的元素是不是1:"<<b.test(0)<<endl;
cout<<"把下标为i的元素变为1:"<<b.set(2)<<endl;      //10111
cout<<"第i位归零"<<b.reset(2)<<endl;        //10011
cout<<"所有位归零:"<<b.reset()<<endl;   //00000
cout<<"第i位取反:"<<b.flip(2)<<endl;        //00100
cout<<"所有位取反:"<<b.flip()<<endl;        //11011
```
